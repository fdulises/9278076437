'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Webcam = function () {
  function Webcam(webcamElement) {
    var facingMode = arguments.length <= 1 || arguments[1] === undefined ? 'user' : arguments[1];
    var canvasElement = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
    var snapSoundElement = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

    _classCallCheck(this, Webcam);

    this._webcamElement = webcamElement;
    this._webcamElement.width = this._webcamElement.width || 640;
    this._webcamElement.height = this._webcamElement.height || video.width * (3 / 4);
    this._facingMode = facingMode;
    this._webcamList = [];
    this._streamList = [];
    this._selectedDeviceId = '';
    this._canvasElement = canvasElement;
    this._snapSoundElement = snapSoundElement;
  }

  _createClass(Webcam, [{
    key: 'getVideoInputs',


    /* Get all video input devices info */
    value: function getVideoInputs(mediaDevices) {
      var _this = this;

      this._webcamList = [];
      mediaDevices.forEach(function (mediaDevice) {
        if (mediaDevice.kind === 'videoinput') {
          _this._webcamList.push(mediaDevice);
        }
      });
      if (this._webcamList.length == 1) {
        this._facingMode = 'user';
      }
      return this._webcamList;
    }

    /* Get media constraints */

  }, {
    key: 'getMediaConstraints',
    value: function getMediaConstraints() {
      var videoConstraints = {};
      if (this._selectedDeviceId == '') {
        videoConstraints.facingMode = this._facingMode;
      } else {
        videoConstraints.deviceId = { exact: this._selectedDeviceId };
      }
      var constraints = {
        video: videoConstraints,
        audio: false
      };
      return constraints;
    }

    /* Select camera based on facingMode */

  }, {
    key: 'selectCamera',
    value: function selectCamera() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._webcamList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var webcam = _step.value;

          if (this._facingMode == 'user' && webcam.label.toLowerCase().includes('front') || this._facingMode == 'enviroment' && webcam.label.toLowerCase().includes('back')) {
            this._selectedDeviceId = webcam.deviceId;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /* Change Facing mode and selected camera */

  }, {
    key: 'flip',
    value: function flip() {
      this._facingMode = this._facingMode == 'user' ? 'enviroment' : 'user';
      this._webcamElement.style.transform = "";
      this.selectCamera();
    }

    /*
      1. Get permission from user
      2. Get all video input devices info
      3. Select camera based on facingMode 
      4. Start stream
    */

  }, {
    key: 'start',
    value: async function start() {
      var _this2 = this;

      var startStream = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      return new Promise(function (resolve, reject) {
        _this2.stop();
        navigator.mediaDevices.getUserMedia(_this2.getMediaConstraints()) //get permisson from user
        .then(function (stream) {
          _this2._streamList.push(stream);
          _this2.info() //get all video input devices info
          .then(function (webcams) {
            _this2.selectCamera(); //select camera based on facingMode
            if (startStream) {
              _this2.stream().then(function (facingMode) {
                resolve(_this2._facingMode);
              }).catch(function (error) {
                reject(error);
              });
            } else {
              resolve(_this2._selectedDeviceId);
            }
          }).catch(function (error) {
            reject(error);
          });
        }).catch(function (error) {
          reject(error);
        });
      });
    }

    /* Get all video input devices info */

  }, {
    key: 'info',
    value: async function info() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        navigator.mediaDevices.enumerateDevices().then(function (devices) {
          _this3.getVideoInputs(devices);
          resolve(_this3._webcamList);
        }).catch(function (error) {
          reject(error);
        });
      });
    }

    /* Start streaming webcam to video element */

  }, {
    key: 'stream',
    value: async function stream() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        navigator.mediaDevices.getUserMedia(_this4.getMediaConstraints()).then(function (stream) {
          _this4._streamList.push(stream);
          _this4._webcamElement.srcObject = stream;
          if (_this4._facingMode == 'user') {
            _this4._webcamElement.style.transform = "scale(-1,1)";
          }
          _this4._webcamElement.play();
          resolve(_this4._facingMode);
        }).catch(function (error) {
          console.log(error);
          reject(error);
        });
      });
    }

    /* Stop streaming webcam */

  }, {
    key: 'stop',
    value: function stop() {
      this._streamList.forEach(function (stream) {
        stream.getTracks().forEach(function (track) {
          track.stop();
        });
      });
    }
  }, {
    key: 'snap',
    value: function snap() {
      if (this._canvasElement != null) {
        if (this._snapSoundElement != null) {
          this._snapSoundElement.play();
        }
        this._canvasElement.height = this._webcamElement.scrollHeight;
        this._canvasElement.width = this._webcamElement.scrollWidth;
        var context = this._canvasElement.getContext('2d');
        if (this._facingMode == 'user') {
          context.translate(this._canvasElement.width, 0);
          context.scale(-1, 1);
        }
        context.clearRect(0, 0, this._canvasElement.width, this._canvasElement.height);
        context.drawImage(this._webcamElement, 0, 0, this._canvasElement.width, this._canvasElement.height);
        var data = this._canvasElement.toDataURL('image/png');
        return data;
      } else {
        throw "canvas element is missing";
      }
    }
  }, {
    key: 'facingMode',
    get: function get() {
      return this._facingMode;
    },
    set: function set(value) {
      this._facingMode = value;
    }
  }, {
    key: 'webcamList',
    get: function get() {
      return this._webcamList;
    }
  }, {
    key: 'webcamCount',
    get: function get() {
      return this._webcamList.length;
    }
  }, {
    key: 'selectedDeviceId',
    get: function get() {
      return this._selectedDeviceId;
    }
  }]);

  return Webcam;
}();